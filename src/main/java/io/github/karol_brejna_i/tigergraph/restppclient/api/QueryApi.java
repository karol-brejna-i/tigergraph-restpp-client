/*
 * TigerGraph REST++ API
 * Title
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.github.karol_brejna_i.tigergraph.restppclient.api;

import io.github.karol_brejna_i.tigergraph.restppclient.invoker.ApiCallback;
import io.github.karol_brejna_i.tigergraph.restppclient.invoker.ApiClient;
import io.github.karol_brejna_i.tigergraph.restppclient.invoker.ApiException;
import io.github.karol_brejna_i.tigergraph.restppclient.invoker.ApiResponse;
import io.github.karol_brejna_i.tigergraph.restppclient.invoker.Configuration;
import io.github.karol_brejna_i.tigergraph.restppclient.invoker.Pair;
import io.github.karol_brejna_i.tigergraph.restppclient.invoker.ProgressRequestBody;
import io.github.karol_brejna_i.tigergraph.restppclient.invoker.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.github.karol_brejna_i.tigergraph.restppclient.model.AbortQueryResponse;
import io.github.karol_brejna_i.tigergraph.restppclient.model.ErrorResponse;
import io.github.karol_brejna_i.tigergraph.restppclient.model.ProcessListResponse;
import io.github.karol_brejna_i.tigergraph.restppclient.model.QueryResponse;
import io.github.karol_brejna_i.tigergraph.restppclient.model.QueryStatusResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class QueryApi {
    private ApiClient apiClient;

    public QueryApi() {
        this(Configuration.getDefaultApiClient());
    }

    public QueryApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for abortQueryGet
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param requestid The id of a query request. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call abortQueryGetCall(String graphName, String requestid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/abortquery/{graph_name}"
            .replaceAll("\\{" + "graph_name" + "\\}", apiClient.escapeString(graphName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (requestid != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("requestid", requestid));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call abortQueryGetValidateBeforeCall(String graphName, String requestid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'graphName' is set
        if (graphName == null) {
            throw new ApiException("Missing the required parameter 'graphName' when calling abortQueryGet(Async)");
        }
        // verify the required parameter 'requestid' is set
        if (requestid == null) {
            throw new ApiException("Missing the required parameter 'requestid' when calling abortQueryGet(Async)");
        }
        
        com.squareup.okhttp.Call call = abortQueryGetCall(graphName, requestid, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Abort a query
     * This endpoint safely aborts a selected query by ID or all queries of an endpoint by endpoint URL of a graph.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_abort_a_query 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param requestid The id of a query request. (required)
     * @return AbortQueryResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public AbortQueryResponse abortQueryGet(String graphName, String requestid) throws ApiException {
        ApiResponse<AbortQueryResponse> resp = abortQueryGetWithHttpInfo(graphName, requestid);
        return resp.getData();
    }

    /**
     * Abort a query
     * This endpoint safely aborts a selected query by ID or all queries of an endpoint by endpoint URL of a graph.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_abort_a_query 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param requestid The id of a query request. (required)
     * @return ApiResponse&lt;AbortQueryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<AbortQueryResponse> abortQueryGetWithHttpInfo(String graphName, String requestid) throws ApiException {
        com.squareup.okhttp.Call call = abortQueryGetValidateBeforeCall(graphName, requestid, null, null);
        Type localVarReturnType = new TypeToken<AbortQueryResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Abort a query (asynchronously)
     * This endpoint safely aborts a selected query by ID or all queries of an endpoint by endpoint URL of a graph.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_abort_a_query 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param requestid The id of a query request. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call abortQueryGetAsync(String graphName, String requestid, final ApiCallback<AbortQueryResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = abortQueryGetValidateBeforeCall(graphName, requestid, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<AbortQueryResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for abortQueryPost
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call abortQueryPostCall(String graphName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/abortquery/{graph_name}"
            .replaceAll("\\{" + "graph_name" + "\\}", apiClient.escapeString(graphName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call abortQueryPostValidateBeforeCall(String graphName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'graphName' is set
        if (graphName == null) {
            throw new ApiException("Missing the required parameter 'graphName' when calling abortQueryPost(Async)");
        }
        
        com.squareup.okhttp.Call call = abortQueryPostCall(graphName, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Abort a query ** NOT TESTED **
     * This endpoint safely aborts a selected query by ID or all queries of an endpoint by endpoint URL of a graph.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_abort_a_query 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @return AbortQueryResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public AbortQueryResponse abortQueryPost(String graphName) throws ApiException {
        ApiResponse<AbortQueryResponse> resp = abortQueryPostWithHttpInfo(graphName);
        return resp.getData();
    }

    /**
     * Abort a query ** NOT TESTED **
     * This endpoint safely aborts a selected query by ID or all queries of an endpoint by endpoint URL of a graph.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_abort_a_query 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @return ApiResponse&lt;AbortQueryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<AbortQueryResponse> abortQueryPostWithHttpInfo(String graphName) throws ApiException {
        com.squareup.okhttp.Call call = abortQueryPostValidateBeforeCall(graphName, null, null);
        Type localVarReturnType = new TypeToken<AbortQueryResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Abort a query ** NOT TESTED ** (asynchronously)
     * This endpoint safely aborts a selected query by ID or all queries of an endpoint by endpoint URL of a graph.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_abort_a_query 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call abortQueryPostAsync(String graphName, final ApiCallback<AbortQueryResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = abortQueryPostValidateBeforeCall(graphName, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<AbortQueryResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for queryStatus
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param requestid The id of a query request. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call queryStatusCall(String graphName, List<String> requestid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/query_status/{graph_name}"
            .replaceAll("\\{" + "graph_name" + "\\}", apiClient.escapeString(graphName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (requestid != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "requestid", requestid));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call queryStatusValidateBeforeCall(String graphName, List<String> requestid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'graphName' is set
        if (graphName == null) {
            throw new ApiException("Missing the required parameter 'graphName' when calling queryStatus(Async)");
        }
        // verify the required parameter 'requestid' is set
        if (requestid == null) {
            throw new ApiException("Missing the required parameter 'requestid' when calling queryStatus(Async)");
        }
        
        com.squareup.okhttp.Call call = queryStatusCall(graphName, requestid, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Check query status (Detached Mode)
     * This endpoint allows you to check the status of a query run in detached mode.  https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_check_query_status_detached_modes 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param requestid The id of a query request. (required)
     * @return QueryStatusResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public QueryStatusResponse queryStatus(String graphName, List<String> requestid) throws ApiException {
        ApiResponse<QueryStatusResponse> resp = queryStatusWithHttpInfo(graphName, requestid);
        return resp.getData();
    }

    /**
     * Check query status (Detached Mode)
     * This endpoint allows you to check the status of a query run in detached mode.  https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_check_query_status_detached_modes 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param requestid The id of a query request. (required)
     * @return ApiResponse&lt;QueryStatusResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<QueryStatusResponse> queryStatusWithHttpInfo(String graphName, List<String> requestid) throws ApiException {
        com.squareup.okhttp.Call call = queryStatusValidateBeforeCall(graphName, requestid, null, null);
        Type localVarReturnType = new TypeToken<QueryStatusResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Check query status (Detached Mode) (asynchronously)
     * This endpoint allows you to check the status of a query run in detached mode.  https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_check_query_status_detached_modes 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param requestid The id of a query request. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call queryStatusAsync(String graphName, List<String> requestid, final ApiCallback<QueryStatusResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = queryStatusValidateBeforeCall(graphName, requestid, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<QueryStatusResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for runInstalledQueryGet
     * @param graphName Graph name (required)
     * @param queryName Query name (required)
     * @param GSQL_REPLICA If you have a TigerGraph HA cluster, you can specify a query to run on a particular replica with the HTTP header GSQL-REPLICA. The value of the header needs to be an integer within the range one to the replication factor of the cluster. If you supply a invalid value for the header, the request will return an error.  (optional)
     * @param GSQL_THREAD_LIMIT When running a query through RESTPP, you can specify a limit on the number of threads that the query is allowed to use on each node. The number of threads used by a query means the number of vCPUs used by the query. By default, a query will use all threads that are available on a machine.  (optional)
     * @param GSQL_TIMEOUT By default, an HTTP request in the TigerGraph system times out after 16 seconds.  To customize this timeout limit for a particular query instance, you can set the GSQL-TIMEOUT parameter in the request header. The value is an integer in miliseconds. See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_gsql_query_timeout  (optional)
     * @param GSQL_ASYNC Installed queries can run in Detached Mode. To do this, use the GSQL-ASYNCheader and set its value to true.  The results and status of the queries run in Detached Mode can be retrieved with a query ID,  which is returned immediately when queries are executed in Detached Mode.  (optional, default to false)
     * @param RESPONSE_LIMIT Allows for specyfing the response size limit (in bytes) of an HTTP request. If the response size is larger than the given limit, an error message will be returned instead of the actual query result.  See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_response_size  (optional)
     * @param readCommitted Boolean value that indicates whether to use read-committed isolation level for the query. At the read committed level, it is guaranteed that any data read is committed at the moment it is read. By default, it is off.  (optional)
     * @param params When using a GET request to run an installed query, the query parameters are passed in through the query string of the URL.  (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call runInstalledQueryGetCall(String graphName, String queryName, Integer GSQL_REPLICA, Integer GSQL_THREAD_LIMIT, Integer GSQL_TIMEOUT, Boolean GSQL_ASYNC, Integer RESPONSE_LIMIT, Boolean readCommitted, List<Pair> params, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/query/{graph_name}/{query_name}"
            .replaceAll("\\{" + "graph_name" + "\\}", apiClient.escapeString(graphName.toString()))
            .replaceAll("\\{" + "query_name" + "\\}", apiClient.escapeString(queryName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (readCommitted != null)
            localVarQueryParams.addAll(apiClient.parameterToPair("read_committed", readCommitted));

        // XXX TODO another hand-made correction to the original (generated code); it treated params as a multiparam, not many different params
        if (params != null)
            localVarQueryParams.addAll(params);

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (GSQL_REPLICA != null)
        localVarHeaderParams.put("GSQL-REPLICA", apiClient.parameterToString(GSQL_REPLICA));
        if (GSQL_THREAD_LIMIT != null)
        localVarHeaderParams.put("GSQL-THREAD-LIMIT", apiClient.parameterToString(GSQL_THREAD_LIMIT));
        if (GSQL_TIMEOUT != null)
        localVarHeaderParams.put("GSQL-TIMEOUT", apiClient.parameterToString(GSQL_TIMEOUT));
        if (GSQL_ASYNC != null)
        localVarHeaderParams.put("GSQL-ASYNC", apiClient.parameterToString(GSQL_ASYNC));
        if (RESPONSE_LIMIT != null)
        localVarHeaderParams.put("RESPONSE-LIMIT", apiClient.parameterToString(RESPONSE_LIMIT));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call runInstalledQueryGetValidateBeforeCall(String graphName, String queryName, Integer GSQL_REPLICA, Integer GSQL_THREAD_LIMIT, Integer GSQL_TIMEOUT, Boolean GSQL_ASYNC, Integer RESPONSE_LIMIT, Boolean readCommitted, Map<String, String> params, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'graphName' is set
        if (graphName == null) {
            throw new ApiException("Missing the required parameter 'graphName' when calling runInstalledQueryGet(Async)");
        }
        // verify the required parameter 'queryName' is set
        if (queryName == null) {
            throw new ApiException("Missing the required parameter 'queryName' when calling runInstalledQueryGet(Async)");
        }

        // XXX generated code has Map<String, String> in method signature; we need to convert it to list of Pairs...
        // or maybe it would be better to change the signature...
        List<Pair> nvpList = null;
        if (params != null) {
            nvpList = new ArrayList<>(params.size());
            for (Map.Entry<String, String> entry : params.entrySet()) {
                nvpList.add(new Pair(entry.getKey(), entry.getValue()));
            }
        }        
        com.squareup.okhttp.Call call = runInstalledQueryGetCall(graphName, queryName, GSQL_REPLICA, GSQL_THREAD_LIMIT, GSQL_TIMEOUT, GSQL_ASYNC, RESPONSE_LIMIT, readCommitted, nvpList, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Run an installed query
     * Each time a new TigerGraph query is installed, a dynamic endpoint is generated. This new endpoint enables the user to run the new TigerGraph query through HTTP requests and giving the parameters in URL or in a data payload. In the case of a GET request, parameters should be passed in through the query string. 
     * @param graphName Graph name (required)
     * @param queryName Query name (required)
     * @param GSQL_REPLICA If you have a TigerGraph HA cluster, you can specify a query to run on a particular replica with the HTTP header GSQL-REPLICA. The value of the header needs to be an integer within the range one to the replication factor of the cluster. If you supply a invalid value for the header, the request will return an error.  (optional)
     * @param GSQL_THREAD_LIMIT When running a query through RESTPP, you can specify a limit on the number of threads that the query is allowed to use on each node. The number of threads used by a query means the number of vCPUs used by the query. By default, a query will use all threads that are available on a machine.  (optional)
     * @param GSQL_TIMEOUT By default, an HTTP request in the TigerGraph system times out after 16 seconds.  To customize this timeout limit for a particular query instance, you can set the GSQL-TIMEOUT parameter in the request header. The value is an integer in miliseconds. See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_gsql_query_timeout  (optional)
     * @param GSQL_ASYNC Installed queries can run in Detached Mode. To do this, use the GSQL-ASYNCheader and set its value to true.  The results and status of the queries run in Detached Mode can be retrieved with a query ID,  which is returned immediately when queries are executed in Detached Mode.  (optional, default to false)
     * @param RESPONSE_LIMIT Allows for specyfing the response size limit (in bytes) of an HTTP request. If the response size is larger than the given limit, an error message will be returned instead of the actual query result.  See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_response_size  (optional)
     * @param readCommitted Boolean value that indicates whether to use read-committed isolation level for the query. At the read committed level, it is guaranteed that any data read is committed at the moment it is read. By default, it is off.  (optional)
     * @param params When using a GET request to run an installed query, the query parameters are passed in through the query string of the URL.  (optional)
     * @return QueryResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public QueryResponse runInstalledQueryGet(String graphName, String queryName, Integer GSQL_REPLICA, Integer GSQL_THREAD_LIMIT, Integer GSQL_TIMEOUT, Boolean GSQL_ASYNC, Integer RESPONSE_LIMIT, Boolean readCommitted, Map<String, String> params) throws ApiException {
        ApiResponse<QueryResponse> resp = runInstalledQueryGetWithHttpInfo(graphName, queryName, GSQL_REPLICA, GSQL_THREAD_LIMIT, GSQL_TIMEOUT, GSQL_ASYNC, RESPONSE_LIMIT, readCommitted, params);
        return resp.getData();
    }

    /**
     * Run an installed query
     * Each time a new TigerGraph query is installed, a dynamic endpoint is generated. This new endpoint enables the user to run the new TigerGraph query through HTTP requests and giving the parameters in URL or in a data payload. In the case of a GET request, parameters should be passed in through the query string. 
     * @param graphName Graph name (required)
     * @param queryName Query name (required)
     * @param GSQL_REPLICA If you have a TigerGraph HA cluster, you can specify a query to run on a particular replica with the HTTP header GSQL-REPLICA. The value of the header needs to be an integer within the range one to the replication factor of the cluster. If you supply a invalid value for the header, the request will return an error.  (optional)
     * @param GSQL_THREAD_LIMIT When running a query through RESTPP, you can specify a limit on the number of threads that the query is allowed to use on each node. The number of threads used by a query means the number of vCPUs used by the query. By default, a query will use all threads that are available on a machine.  (optional)
     * @param GSQL_TIMEOUT By default, an HTTP request in the TigerGraph system times out after 16 seconds.  To customize this timeout limit for a particular query instance, you can set the GSQL-TIMEOUT parameter in the request header. The value is an integer in miliseconds. See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_gsql_query_timeout  (optional)
     * @param GSQL_ASYNC Installed queries can run in Detached Mode. To do this, use the GSQL-ASYNCheader and set its value to true.  The results and status of the queries run in Detached Mode can be retrieved with a query ID,  which is returned immediately when queries are executed in Detached Mode.  (optional, default to false)
     * @param RESPONSE_LIMIT Allows for specyfing the response size limit (in bytes) of an HTTP request. If the response size is larger than the given limit, an error message will be returned instead of the actual query result.  See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_response_size  (optional)
     * @param readCommitted Boolean value that indicates whether to use read-committed isolation level for the query. At the read committed level, it is guaranteed that any data read is committed at the moment it is read. By default, it is off.  (optional)
     * @param params When using a GET request to run an installed query, the query parameters are passed in through the query string of the URL.  (optional)
     * @return ApiResponse&lt;QueryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<QueryResponse> runInstalledQueryGetWithHttpInfo(String graphName, String queryName, Integer GSQL_REPLICA, Integer GSQL_THREAD_LIMIT, Integer GSQL_TIMEOUT, Boolean GSQL_ASYNC, Integer RESPONSE_LIMIT, Boolean readCommitted, Map<String, String> params) throws ApiException {
        com.squareup.okhttp.Call call = runInstalledQueryGetValidateBeforeCall(graphName, queryName, GSQL_REPLICA, GSQL_THREAD_LIMIT, GSQL_TIMEOUT, GSQL_ASYNC, RESPONSE_LIMIT, readCommitted, params, null, null);
        Type localVarReturnType = new TypeToken<QueryResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Run an installed query (asynchronously)
     * Each time a new TigerGraph query is installed, a dynamic endpoint is generated. This new endpoint enables the user to run the new TigerGraph query through HTTP requests and giving the parameters in URL or in a data payload. In the case of a GET request, parameters should be passed in through the query string. 
     * @param graphName Graph name (required)
     * @param queryName Query name (required)
     * @param GSQL_REPLICA If you have a TigerGraph HA cluster, you can specify a query to run on a particular replica with the HTTP header GSQL-REPLICA. The value of the header needs to be an integer within the range one to the replication factor of the cluster. If you supply a invalid value for the header, the request will return an error.  (optional)
     * @param GSQL_THREAD_LIMIT When running a query through RESTPP, you can specify a limit on the number of threads that the query is allowed to use on each node. The number of threads used by a query means the number of vCPUs used by the query. By default, a query will use all threads that are available on a machine.  (optional)
     * @param GSQL_TIMEOUT By default, an HTTP request in the TigerGraph system times out after 16 seconds.  To customize this timeout limit for a particular query instance, you can set the GSQL-TIMEOUT parameter in the request header. The value is an integer in miliseconds. See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_gsql_query_timeout  (optional)
     * @param GSQL_ASYNC Installed queries can run in Detached Mode. To do this, use the GSQL-ASYNCheader and set its value to true.  The results and status of the queries run in Detached Mode can be retrieved with a query ID,  which is returned immediately when queries are executed in Detached Mode.  (optional, default to false)
     * @param RESPONSE_LIMIT Allows for specyfing the response size limit (in bytes) of an HTTP request. If the response size is larger than the given limit, an error message will be returned instead of the actual query result.  See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_response_size  (optional)
     * @param readCommitted Boolean value that indicates whether to use read-committed isolation level for the query. At the read committed level, it is guaranteed that any data read is committed at the moment it is read. By default, it is off.  (optional)
     * @param params When using a GET request to run an installed query, the query parameters are passed in through the query string of the URL.  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call runInstalledQueryGetAsync(String graphName, String queryName, Integer GSQL_REPLICA, Integer GSQL_THREAD_LIMIT, Integer GSQL_TIMEOUT, Boolean GSQL_ASYNC, Integer RESPONSE_LIMIT, Boolean readCommitted, Map<String, String> params, final ApiCallback<QueryResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = runInstalledQueryGetValidateBeforeCall(graphName, queryName, GSQL_REPLICA, GSQL_THREAD_LIMIT, GSQL_TIMEOUT, GSQL_ASYNC, RESPONSE_LIMIT, readCommitted, params, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<QueryResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for runInstalledQueryPost
     * @param graphName Graph name (required)
     * @param queryName Query name (required)
     * @param body Optional description in *Markdown* (optional)
     * @param GSQL_REPLICA If you have a TigerGraph HA cluster, you can specify a query to run on a particular replica with the HTTP header GSQL-REPLICA. The value of the header needs to be an integer within the range one to the replication factor of the cluster. If you supply a invalid value for the header, the request will return an error.  (optional)
     * @param GSQL_THREAD_LIMIT When running a query through RESTPP, you can specify a limit on the number of threads that the query is allowed to use on each node. The number of threads used by a query means the number of vCPUs used by the query. By default, a query will use all threads that are available on a machine.  (optional)
     * @param GSQL_TIMEOUT By default, an HTTP request in the TigerGraph system times out after 16 seconds.  To customize this timeout limit for a particular query instance, you can set the GSQL-TIMEOUT parameter in the request header. The value is an integer in miliseconds. See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_gsql_query_timeout  (optional)
     * @param GSQL_ASYNC Installed queries can run in Detached Mode. To do this, use the GSQL-ASYNCheader and set its value to true.  The results and status of the queries run in Detached Mode can be retrieved with a query ID,  which is returned immediately when queries are executed in Detached Mode.  (optional, default to false)
     * @param RESPONSE_LIMIT Allows for specyfing the response size limit (in bytes) of an HTTP request. If the response size is larger than the given limit, an error message will be returned instead of the actual query result.  See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_response_size  (optional)
     * @param readCommitted Boolean value that indicates whether to use read-committed isolation level for the query. At the read committed level, it is guaranteed that any data read is committed at the moment it is read. By default, it is off.  (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call runInstalledQueryPostCall(String graphName, String queryName, Object body, Integer GSQL_REPLICA, Integer GSQL_THREAD_LIMIT, Integer GSQL_TIMEOUT, Boolean GSQL_ASYNC, Integer RESPONSE_LIMIT, Boolean readCommitted, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/query/{graph_name}/{query_name}"
            .replaceAll("\\{" + "graph_name" + "\\}", apiClient.escapeString(graphName.toString()))
            .replaceAll("\\{" + "query_name" + "\\}", apiClient.escapeString(queryName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (readCommitted != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("read_committed", readCommitted));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (GSQL_REPLICA != null)
        localVarHeaderParams.put("GSQL-REPLICA", apiClient.parameterToString(GSQL_REPLICA));
        if (GSQL_THREAD_LIMIT != null)
        localVarHeaderParams.put("GSQL-THREAD-LIMIT", apiClient.parameterToString(GSQL_THREAD_LIMIT));
        if (GSQL_TIMEOUT != null)
        localVarHeaderParams.put("GSQL-TIMEOUT", apiClient.parameterToString(GSQL_TIMEOUT));
        if (GSQL_ASYNC != null)
        localVarHeaderParams.put("GSQL-ASYNC", apiClient.parameterToString(GSQL_ASYNC));
        if (RESPONSE_LIMIT != null)
        localVarHeaderParams.put("RESPONSE-LIMIT", apiClient.parameterToString(RESPONSE_LIMIT));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call runInstalledQueryPostValidateBeforeCall(String graphName, String queryName, Object body, Integer GSQL_REPLICA, Integer GSQL_THREAD_LIMIT, Integer GSQL_TIMEOUT, Boolean GSQL_ASYNC, Integer RESPONSE_LIMIT, Boolean readCommitted, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'graphName' is set
        if (graphName == null) {
            throw new ApiException("Missing the required parameter 'graphName' when calling runInstalledQueryPost(Async)");
        }
        // verify the required parameter 'queryName' is set
        if (queryName == null) {
            throw new ApiException("Missing the required parameter 'queryName' when calling runInstalledQueryPost(Async)");
        }
        
        com.squareup.okhttp.Call call = runInstalledQueryPostCall(graphName, queryName, body, GSQL_REPLICA, GSQL_THREAD_LIMIT, GSQL_TIMEOUT, GSQL_ASYNC, RESPONSE_LIMIT, readCommitted, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Run an installed query
     * Each time a new TigerGraph query is installed, a dynamic endpoint is generated. This new endpoint enables the user to run the new TigerGraph query through HTTP requests and giving the parameters in URL or in a data payload.  Users can run queries through a POST request, which allows them to pass query parameters in JSON. This is especially helpful when the query takes complex parameters. 
     * @param graphName Graph name (required)
     * @param queryName Query name (required)
     * @param body Optional description in *Markdown* (optional)
     * @param GSQL_REPLICA If you have a TigerGraph HA cluster, you can specify a query to run on a particular replica with the HTTP header GSQL-REPLICA. The value of the header needs to be an integer within the range one to the replication factor of the cluster. If you supply a invalid value for the header, the request will return an error.  (optional)
     * @param GSQL_THREAD_LIMIT When running a query through RESTPP, you can specify a limit on the number of threads that the query is allowed to use on each node. The number of threads used by a query means the number of vCPUs used by the query. By default, a query will use all threads that are available on a machine.  (optional)
     * @param GSQL_TIMEOUT By default, an HTTP request in the TigerGraph system times out after 16 seconds.  To customize this timeout limit for a particular query instance, you can set the GSQL-TIMEOUT parameter in the request header. The value is an integer in miliseconds. See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_gsql_query_timeout  (optional)
     * @param GSQL_ASYNC Installed queries can run in Detached Mode. To do this, use the GSQL-ASYNCheader and set its value to true.  The results and status of the queries run in Detached Mode can be retrieved with a query ID,  which is returned immediately when queries are executed in Detached Mode.  (optional, default to false)
     * @param RESPONSE_LIMIT Allows for specyfing the response size limit (in bytes) of an HTTP request. If the response size is larger than the given limit, an error message will be returned instead of the actual query result.  See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_response_size  (optional)
     * @param readCommitted Boolean value that indicates whether to use read-committed isolation level for the query. At the read committed level, it is guaranteed that any data read is committed at the moment it is read. By default, it is off.  (optional)
     * @return QueryResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public QueryResponse runInstalledQueryPost(String graphName, String queryName, Object body, Integer GSQL_REPLICA, Integer GSQL_THREAD_LIMIT, Integer GSQL_TIMEOUT, Boolean GSQL_ASYNC, Integer RESPONSE_LIMIT, Boolean readCommitted) throws ApiException {
        ApiResponse<QueryResponse> resp = runInstalledQueryPostWithHttpInfo(graphName, queryName, body, GSQL_REPLICA, GSQL_THREAD_LIMIT, GSQL_TIMEOUT, GSQL_ASYNC, RESPONSE_LIMIT, readCommitted);
        return resp.getData();
    }

    /**
     * Run an installed query
     * Each time a new TigerGraph query is installed, a dynamic endpoint is generated. This new endpoint enables the user to run the new TigerGraph query through HTTP requests and giving the parameters in URL or in a data payload.  Users can run queries through a POST request, which allows them to pass query parameters in JSON. This is especially helpful when the query takes complex parameters. 
     * @param graphName Graph name (required)
     * @param queryName Query name (required)
     * @param body Optional description in *Markdown* (optional)
     * @param GSQL_REPLICA If you have a TigerGraph HA cluster, you can specify a query to run on a particular replica with the HTTP header GSQL-REPLICA. The value of the header needs to be an integer within the range one to the replication factor of the cluster. If you supply a invalid value for the header, the request will return an error.  (optional)
     * @param GSQL_THREAD_LIMIT When running a query through RESTPP, you can specify a limit on the number of threads that the query is allowed to use on each node. The number of threads used by a query means the number of vCPUs used by the query. By default, a query will use all threads that are available on a machine.  (optional)
     * @param GSQL_TIMEOUT By default, an HTTP request in the TigerGraph system times out after 16 seconds.  To customize this timeout limit for a particular query instance, you can set the GSQL-TIMEOUT parameter in the request header. The value is an integer in miliseconds. See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_gsql_query_timeout  (optional)
     * @param GSQL_ASYNC Installed queries can run in Detached Mode. To do this, use the GSQL-ASYNCheader and set its value to true.  The results and status of the queries run in Detached Mode can be retrieved with a query ID,  which is returned immediately when queries are executed in Detached Mode.  (optional, default to false)
     * @param RESPONSE_LIMIT Allows for specyfing the response size limit (in bytes) of an HTTP request. If the response size is larger than the given limit, an error message will be returned instead of the actual query result.  See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_response_size  (optional)
     * @param readCommitted Boolean value that indicates whether to use read-committed isolation level for the query. At the read committed level, it is guaranteed that any data read is committed at the moment it is read. By default, it is off.  (optional)
     * @return ApiResponse&lt;QueryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<QueryResponse> runInstalledQueryPostWithHttpInfo(String graphName, String queryName, Object body, Integer GSQL_REPLICA, Integer GSQL_THREAD_LIMIT, Integer GSQL_TIMEOUT, Boolean GSQL_ASYNC, Integer RESPONSE_LIMIT, Boolean readCommitted) throws ApiException {
        com.squareup.okhttp.Call call = runInstalledQueryPostValidateBeforeCall(graphName, queryName, body, GSQL_REPLICA, GSQL_THREAD_LIMIT, GSQL_TIMEOUT, GSQL_ASYNC, RESPONSE_LIMIT, readCommitted, null, null);
        Type localVarReturnType = new TypeToken<QueryResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Run an installed query (asynchronously)
     * Each time a new TigerGraph query is installed, a dynamic endpoint is generated. This new endpoint enables the user to run the new TigerGraph query through HTTP requests and giving the parameters in URL or in a data payload.  Users can run queries through a POST request, which allows them to pass query parameters in JSON. This is especially helpful when the query takes complex parameters. 
     * @param graphName Graph name (required)
     * @param queryName Query name (required)
     * @param body Optional description in *Markdown* (optional)
     * @param GSQL_REPLICA If you have a TigerGraph HA cluster, you can specify a query to run on a particular replica with the HTTP header GSQL-REPLICA. The value of the header needs to be an integer within the range one to the replication factor of the cluster. If you supply a invalid value for the header, the request will return an error.  (optional)
     * @param GSQL_THREAD_LIMIT When running a query through RESTPP, you can specify a limit on the number of threads that the query is allowed to use on each node. The number of threads used by a query means the number of vCPUs used by the query. By default, a query will use all threads that are available on a machine.  (optional)
     * @param GSQL_TIMEOUT By default, an HTTP request in the TigerGraph system times out after 16 seconds.  To customize this timeout limit for a particular query instance, you can set the GSQL-TIMEOUT parameter in the request header. The value is an integer in miliseconds. See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_gsql_query_timeout  (optional)
     * @param GSQL_ASYNC Installed queries can run in Detached Mode. To do this, use the GSQL-ASYNCheader and set its value to true.  The results and status of the queries run in Detached Mode can be retrieved with a query ID,  which is returned immediately when queries are executed in Detached Mode.  (optional, default to false)
     * @param RESPONSE_LIMIT Allows for specyfing the response size limit (in bytes) of an HTTP request. If the response size is larger than the given limit, an error message will be returned instead of the actual query result.  See: https://docs.tigergraph.com/tigergraph-server/current/api/intro#_response_size  (optional)
     * @param readCommitted Boolean value that indicates whether to use read-committed isolation level for the query. At the read committed level, it is guaranteed that any data read is committed at the moment it is read. By default, it is off.  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call runInstalledQueryPostAsync(String graphName, String queryName, Object body, Integer GSQL_REPLICA, Integer GSQL_THREAD_LIMIT, Integer GSQL_TIMEOUT, Boolean GSQL_ASYNC, Integer RESPONSE_LIMIT, Boolean readCommitted, final ApiCallback<QueryResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = runInstalledQueryPostValidateBeforeCall(graphName, queryName, body, GSQL_REPLICA, GSQL_THREAD_LIMIT, GSQL_TIMEOUT, GSQL_ASYNC, RESPONSE_LIMIT, readCommitted, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<QueryResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for showProcessListGet
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call showProcessListGetCall(String graphName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/showprocesslist/{graph_name}"
            .replaceAll("\\{" + "graph_name" + "\\}", apiClient.escapeString(graphName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call showProcessListGetValidateBeforeCall(String graphName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'graphName' is set
        if (graphName == null) {
            throw new ApiException("Missing the required parameter 'graphName' when calling showProcessListGet(Async)");
        }
        
        com.squareup.okhttp.Call call = showProcessListGetCall(graphName, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * List running queries
     * This endpoint reports statistics of running queries of a graph: the querys request ID, start time, expiration time, and the REST endpoints URL  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_list_running_queries 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @return ProcessListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ProcessListResponse showProcessListGet(String graphName) throws ApiException {
        ApiResponse<ProcessListResponse> resp = showProcessListGetWithHttpInfo(graphName);
        return resp.getData();
    }

    /**
     * List running queries
     * This endpoint reports statistics of running queries of a graph: the querys request ID, start time, expiration time, and the REST endpoints URL  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_list_running_queries 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @return ApiResponse&lt;ProcessListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ProcessListResponse> showProcessListGetWithHttpInfo(String graphName) throws ApiException {
        com.squareup.okhttp.Call call = showProcessListGetValidateBeforeCall(graphName, null, null);
        Type localVarReturnType = new TypeToken<ProcessListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * List running queries (asynchronously)
     * This endpoint reports statistics of running queries of a graph: the querys request ID, start time, expiration time, and the REST endpoints URL  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_list_running_queries 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call showProcessListGetAsync(String graphName, final ApiCallback<ProcessListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = showProcessListGetValidateBeforeCall(graphName, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ProcessListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for showProcessListPost
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call showProcessListPostCall(String graphName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/showprocesslist/{graph_name}"
            .replaceAll("\\{" + "graph_name" + "\\}", apiClient.escapeString(graphName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call showProcessListPostValidateBeforeCall(String graphName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'graphName' is set
        if (graphName == null) {
            throw new ApiException("Missing the required parameter 'graphName' when calling showProcessListPost(Async)");
        }
        
        com.squareup.okhttp.Call call = showProcessListPostCall(graphName, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * TODO XXX listed in /endpoints results, but not mentioned in the docs...
     * 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @return ProcessListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ProcessListResponse showProcessListPost(String graphName) throws ApiException {
        ApiResponse<ProcessListResponse> resp = showProcessListPostWithHttpInfo(graphName);
        return resp.getData();
    }

    /**
     * TODO XXX listed in /endpoints results, but not mentioned in the docs...
     * 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @return ApiResponse&lt;ProcessListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ProcessListResponse> showProcessListPostWithHttpInfo(String graphName) throws ApiException {
        com.squareup.okhttp.Call call = showProcessListPostValidateBeforeCall(graphName, null, null);
        Type localVarReturnType = new TypeToken<ProcessListResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * TODO XXX listed in /endpoints results, but not mentioned in the docs... (asynchronously)
     * 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call showProcessListPostAsync(String graphName, final ApiCallback<ProcessListResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = showProcessListPostValidateBeforeCall(graphName, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ProcessListResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    public QueryResponse runInstalledQueryGet(String graphName, String queryName) throws ApiException {
        return this.runInstalledQueryGet(graphName, queryName,
                null, null, null, null, null, null,
                null);
    }
    public QueryResponse runInstalledQueryPost(String graphName, String queryName, HashMap<String, Object> body) throws ApiException {
        return this.runInstalledQueryPost(graphName, queryName, body,
                null, null, null, null, null, null);
    }
    public QueryResponse runInstalledQueryGet(String graphName, String queryName, HashMap<String, String> params) throws ApiException {
        return this.runInstalledQueryGet(graphName, queryName,
                null, null, null, null, null, null,
                params);
    }
}
