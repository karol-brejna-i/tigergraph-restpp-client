/*
 * TigerGraph REST++ API
 * Title
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.github.karol_brejna_i.tigergraph.restppclient.api;

import io.github.karol_brejna_i.tigergraph.restppclient.invoker.ApiCallback;
import io.github.karol_brejna_i.tigergraph.restppclient.invoker.ApiClient;
import io.github.karol_brejna_i.tigergraph.restppclient.invoker.ApiException;
import io.github.karol_brejna_i.tigergraph.restppclient.invoker.ApiResponse;
import io.github.karol_brejna_i.tigergraph.restppclient.invoker.Configuration;
import io.github.karol_brejna_i.tigergraph.restppclient.invoker.Pair;
import io.github.karol_brejna_i.tigergraph.restppclient.invoker.ProgressRequestBody;
import io.github.karol_brejna_i.tigergraph.restppclient.invoker.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.github.karol_brejna_i.tigergraph.restppclient.model.AnyObject;
import io.github.karol_brejna_i.tigergraph.restppclient.model.HelloResponse;
import io.github.karol_brejna_i.tigergraph.restppclient.model.StatisticsResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DiagnosticsApi {
    private ApiClient apiClient;

    public DiagnosticsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public DiagnosticsApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for echoGet
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call echoGetCall(String graphName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/echo/{graph_name}"
            .replaceAll("\\{" + "graph_name" + "\\}", apiClient.escapeString(graphName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call echoGetValidateBeforeCall(String graphName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'graphName' is set
        if (graphName == null) {
            throw new ApiException("Missing the required parameter 'graphName' when calling echoGet(Async)");
        }
        
        com.squareup.okhttp.Call call = echoGetCall(graphName, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Echo
     * A simple diagnostic utility. Expected response is {\&quot;message\&quot;: \&quot;Hello GSQL\&quot;}.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_echo 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @return HelloResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public HelloResponse echoGet(String graphName) throws ApiException {
        ApiResponse<HelloResponse> resp = echoGetWithHttpInfo(graphName);
        return resp.getData();
    }

    /**
     * Echo
     * A simple diagnostic utility. Expected response is {\&quot;message\&quot;: \&quot;Hello GSQL\&quot;}.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_echo 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @return ApiResponse&lt;HelloResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<HelloResponse> echoGetWithHttpInfo(String graphName) throws ApiException {
        com.squareup.okhttp.Call call = echoGetValidateBeforeCall(graphName, null, null);
        Type localVarReturnType = new TypeToken<HelloResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Echo (asynchronously)
     * A simple diagnostic utility. Expected response is {\&quot;message\&quot;: \&quot;Hello GSQL\&quot;}.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_echo 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call echoGetAsync(String graphName, final ApiCallback<HelloResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = echoGetValidateBeforeCall(graphName, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<HelloResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for echoPost
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call echoPostCall(String graphName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/echo/{graph_name}"
            .replaceAll("\\{" + "graph_name" + "\\}", apiClient.escapeString(graphName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call echoPostValidateBeforeCall(String graphName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'graphName' is set
        if (graphName == null) {
            throw new ApiException("Missing the required parameter 'graphName' when calling echoPost(Async)");
        }
        
        com.squareup.okhttp.Call call = echoPostCall(graphName, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Echo
     * A simple diagnostic utility. Expected response is {\&quot;message\&quot;: \&quot;Hello GSQL\&quot;}.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_echo 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @return HelloResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public HelloResponse echoPost(String graphName) throws ApiException {
        ApiResponse<HelloResponse> resp = echoPostWithHttpInfo(graphName);
        return resp.getData();
    }

    /**
     * Echo
     * A simple diagnostic utility. Expected response is {\&quot;message\&quot;: \&quot;Hello GSQL\&quot;}.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_echo 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @return ApiResponse&lt;HelloResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<HelloResponse> echoPostWithHttpInfo(String graphName) throws ApiException {
        com.squareup.okhttp.Call call = echoPostValidateBeforeCall(graphName, null, null);
        Type localVarReturnType = new TypeToken<HelloResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Echo (asynchronously)
     * A simple diagnostic utility. Expected response is {\&quot;message\&quot;: \&quot;Hello GSQL\&quot;}.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_echo 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call echoPostAsync(String graphName, final ApiCallback<HelloResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = echoPostValidateBeforeCall(graphName, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<HelloResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for endpoints
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param builtin trueEndpoints presinstalled in TigerGraph (like this one). (optional)
     * @param dynamic trueEndpoints generated when installing GSQL queries. (optional)
     * @param _static trueUser installed endpoints. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call endpointsCall(String graphName, Boolean builtin, Boolean dynamic, Boolean _static, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/endpoints/{graph_name}"
            .replaceAll("\\{" + "graph_name" + "\\}", apiClient.escapeString(graphName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (builtin != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("builtin", builtin));
        if (dynamic != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("dynamic", dynamic));
        if (_static != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("static", _static));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call endpointsValidateBeforeCall(String graphName, Boolean builtin, Boolean dynamic, Boolean _static, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'graphName' is set
        if (graphName == null) {
            throw new ApiException("Missing the required parameter 'graphName' when calling endpoints(Async)");
        }
        
        com.squareup.okhttp.Call call = endpointsCall(graphName, builtin, dynamic, _static, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * List all endpoints
     * This endpoint returns a list of the installed endpoints and their parameters. There are three types of endpoints, described in the table below.   * builtin - Endpoints presinstalled in TigerGraph (like this one)   * dynamic - Endpoints generated when installing GSQL queries   * static - User installed endpoints  To include one or more of the endpoint types in the output,  include the endpoint type in the parameter query string and set its value to true. If no type parameters are provided, all endpoints are returned.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_list_all_endpoints See: https://docs.tigergraph.com/tigergraph-server/current/api/json-catalog 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param builtin trueEndpoints presinstalled in TigerGraph (like this one). (optional)
     * @param dynamic trueEndpoints generated when installing GSQL queries. (optional)
     * @param _static trueUser installed endpoints. (optional)
     * @return AnyObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public AnyObject endpoints(String graphName, Boolean builtin, Boolean dynamic, Boolean _static) throws ApiException {
        ApiResponse<AnyObject> resp = endpointsWithHttpInfo(graphName, builtin, dynamic, _static);
        return resp.getData();
    }

    /**
     * List all endpoints
     * This endpoint returns a list of the installed endpoints and their parameters. There are three types of endpoints, described in the table below.   * builtin - Endpoints presinstalled in TigerGraph (like this one)   * dynamic - Endpoints generated when installing GSQL queries   * static - User installed endpoints  To include one or more of the endpoint types in the output,  include the endpoint type in the parameter query string and set its value to true. If no type parameters are provided, all endpoints are returned.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_list_all_endpoints See: https://docs.tigergraph.com/tigergraph-server/current/api/json-catalog 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param builtin trueEndpoints presinstalled in TigerGraph (like this one). (optional)
     * @param dynamic trueEndpoints generated when installing GSQL queries. (optional)
     * @param _static trueUser installed endpoints. (optional)
     * @return ApiResponse&lt;AnyObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<AnyObject> endpointsWithHttpInfo(String graphName, Boolean builtin, Boolean dynamic, Boolean _static) throws ApiException {
        com.squareup.okhttp.Call call = endpointsValidateBeforeCall(graphName, builtin, dynamic, _static, null, null);
        Type localVarReturnType = new TypeToken<AnyObject>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * List all endpoints (asynchronously)
     * This endpoint returns a list of the installed endpoints and their parameters. There are three types of endpoints, described in the table below.   * builtin - Endpoints presinstalled in TigerGraph (like this one)   * dynamic - Endpoints generated when installing GSQL queries   * static - User installed endpoints  To include one or more of the endpoint types in the output,  include the endpoint type in the parameter query string and set its value to true. If no type parameters are provided, all endpoints are returned.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_list_all_endpoints See: https://docs.tigergraph.com/tigergraph-server/current/api/json-catalog 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param builtin trueEndpoints presinstalled in TigerGraph (like this one). (optional)
     * @param dynamic trueEndpoints generated when installing GSQL queries. (optional)
     * @param _static trueUser installed endpoints. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call endpointsAsync(String graphName, Boolean builtin, Boolean dynamic, Boolean _static, final ApiCallback<AnyObject> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = endpointsValidateBeforeCall(graphName, builtin, dynamic, _static, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<AnyObject>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for rebuildnowGet
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param threadnum Number of threads used to execute the rebuild. If not specified, the number specified in the .tg.cfg file  (\&quot;RebuildThreadNumber\&quot;) in the home directory of the server on which TigerGraph  is running will be used; it is set to 3 by default.  The maximum value for this parameter is the number of vCPUs per node in your distributed system.  If you are running a single-node server, the maximum is the number of vCPUs on that node.  You can run lscpu in the command line of your Linux server and look in the CPU(s)  column to view the number of vCPUs.  (optional)
     * @param vertextype Vertex type to perform the rebuild for. If not provided, the rebuild will be run for all the vertex types.  (optional)
     * @param segid Segment ID of the segments to rebuild. If not provided, all segments will be rebuilt.  In general, it is recommended not to provide this parameter and rebuild all segments.  (optional)
     * @param path Path to save the summary of the rebuild to. If not provided, the default path is /tmp/rebuildnow  (optional)
     * @param force Boolean value that indicates whether to perform rebuilds for segments for which there are no records of new data.  Normally, a rebuild would skip such segments, but if force is set true, the segments will not be skipped.  (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call rebuildnowGetCall(String graphName, Integer threadnum, String vertextype, Integer segid, String path, Boolean force, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/rebuildnow/{graph_name}"
            .replaceAll("\\{" + "graph_name" + "\\}", apiClient.escapeString(graphName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (threadnum != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("threadnum", threadnum));
        if (vertextype != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("vertextype", vertextype));
        if (segid != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("segid", segid));
        if (path != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("path", path));
        if (force != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("force", force));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call rebuildnowGetValidateBeforeCall(String graphName, Integer threadnum, String vertextype, Integer segid, String path, Boolean force, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'graphName' is set
        if (graphName == null) {
            throw new ApiException("Missing the required parameter 'graphName' when calling rebuildnowGet(Async)");
        }
        
        com.squareup.okhttp.Call call = rebuildnowGetCall(graphName, threadnum, vertextype, segid, path, force, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Rebuild graph engine
     * In TigerGraph, when new data is being loaded into the graph (such as new vertices or edges),  data is first stored in memory before it is saved to disk permanently.  TigerGraph runs a rebuild of the Graph Processing Engine (GPE) to commit the data in memory to disk  every 30 seconds, but you can also call this endpoint to trigger a rebuild immediately. 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param threadnum Number of threads used to execute the rebuild. If not specified, the number specified in the .tg.cfg file  (\&quot;RebuildThreadNumber\&quot;) in the home directory of the server on which TigerGraph  is running will be used; it is set to 3 by default.  The maximum value for this parameter is the number of vCPUs per node in your distributed system.  If you are running a single-node server, the maximum is the number of vCPUs on that node.  You can run lscpu in the command line of your Linux server and look in the CPU(s)  column to view the number of vCPUs.  (optional)
     * @param vertextype Vertex type to perform the rebuild for. If not provided, the rebuild will be run for all the vertex types.  (optional)
     * @param segid Segment ID of the segments to rebuild. If not provided, all segments will be rebuilt.  In general, it is recommended not to provide this parameter and rebuild all segments.  (optional)
     * @param path Path to save the summary of the rebuild to. If not provided, the default path is /tmp/rebuildnow  (optional)
     * @param force Boolean value that indicates whether to perform rebuilds for segments for which there are no records of new data.  Normally, a rebuild would skip such segments, but if force is set true, the segments will not be skipped.  (optional)
     * @return HelloResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public HelloResponse rebuildnowGet(String graphName, Integer threadnum, String vertextype, Integer segid, String path, Boolean force) throws ApiException {
        ApiResponse<HelloResponse> resp = rebuildnowGetWithHttpInfo(graphName, threadnum, vertextype, segid, path, force);
        return resp.getData();
    }

    /**
     * Rebuild graph engine
     * In TigerGraph, when new data is being loaded into the graph (such as new vertices or edges),  data is first stored in memory before it is saved to disk permanently.  TigerGraph runs a rebuild of the Graph Processing Engine (GPE) to commit the data in memory to disk  every 30 seconds, but you can also call this endpoint to trigger a rebuild immediately. 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param threadnum Number of threads used to execute the rebuild. If not specified, the number specified in the .tg.cfg file  (\&quot;RebuildThreadNumber\&quot;) in the home directory of the server on which TigerGraph  is running will be used; it is set to 3 by default.  The maximum value for this parameter is the number of vCPUs per node in your distributed system.  If you are running a single-node server, the maximum is the number of vCPUs on that node.  You can run lscpu in the command line of your Linux server and look in the CPU(s)  column to view the number of vCPUs.  (optional)
     * @param vertextype Vertex type to perform the rebuild for. If not provided, the rebuild will be run for all the vertex types.  (optional)
     * @param segid Segment ID of the segments to rebuild. If not provided, all segments will be rebuilt.  In general, it is recommended not to provide this parameter and rebuild all segments.  (optional)
     * @param path Path to save the summary of the rebuild to. If not provided, the default path is /tmp/rebuildnow  (optional)
     * @param force Boolean value that indicates whether to perform rebuilds for segments for which there are no records of new data.  Normally, a rebuild would skip such segments, but if force is set true, the segments will not be skipped.  (optional)
     * @return ApiResponse&lt;HelloResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<HelloResponse> rebuildnowGetWithHttpInfo(String graphName, Integer threadnum, String vertextype, Integer segid, String path, Boolean force) throws ApiException {
        com.squareup.okhttp.Call call = rebuildnowGetValidateBeforeCall(graphName, threadnum, vertextype, segid, path, force, null, null);
        Type localVarReturnType = new TypeToken<HelloResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Rebuild graph engine (asynchronously)
     * In TigerGraph, when new data is being loaded into the graph (such as new vertices or edges),  data is first stored in memory before it is saved to disk permanently.  TigerGraph runs a rebuild of the Graph Processing Engine (GPE) to commit the data in memory to disk  every 30 seconds, but you can also call this endpoint to trigger a rebuild immediately. 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param threadnum Number of threads used to execute the rebuild. If not specified, the number specified in the .tg.cfg file  (\&quot;RebuildThreadNumber\&quot;) in the home directory of the server on which TigerGraph  is running will be used; it is set to 3 by default.  The maximum value for this parameter is the number of vCPUs per node in your distributed system.  If you are running a single-node server, the maximum is the number of vCPUs on that node.  You can run lscpu in the command line of your Linux server and look in the CPU(s)  column to view the number of vCPUs.  (optional)
     * @param vertextype Vertex type to perform the rebuild for. If not provided, the rebuild will be run for all the vertex types.  (optional)
     * @param segid Segment ID of the segments to rebuild. If not provided, all segments will be rebuilt.  In general, it is recommended not to provide this parameter and rebuild all segments.  (optional)
     * @param path Path to save the summary of the rebuild to. If not provided, the default path is /tmp/rebuildnow  (optional)
     * @param force Boolean value that indicates whether to perform rebuilds for segments for which there are no records of new data.  Normally, a rebuild would skip such segments, but if force is set true, the segments will not be skipped.  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call rebuildnowGetAsync(String graphName, Integer threadnum, String vertextype, Integer segid, String path, Boolean force, final ApiCallback<HelloResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = rebuildnowGetValidateBeforeCall(graphName, threadnum, vertextype, segid, path, force, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<HelloResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for rebuildnowPost
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param threadnum Number of threads used to execute the rebuild. If not specified, the number specified in the .tg.cfg file  (\&quot;RebuildThreadNumber\&quot;) in the home directory of the server on which TigerGraph  is running will be used; it is set to 3 by default.  The maximum value for this parameter is the number of vCPUs per node in your distributed system.  If you are running a single-node server, the maximum is the number of vCPUs on that node.  You can run lscpu in the command line of your Linux server and look in the CPU(s)  column to view the number of vCPUs.  (optional)
     * @param vertextype Vertex type to perform the rebuild for. If not provided, the rebuild will be run for all the vertex types.  (optional)
     * @param segid Segment ID of the segments to rebuild. If not provided, all segments will be rebuilt.  In general, it is recommended not to provide this parameter and rebuild all segments.  (optional)
     * @param path Path to save the summary of the rebuild to. If not provided, the default path is /tmp/rebuildnow  (optional)
     * @param force Boolean value that indicates whether to perform rebuilds for segments for which there are no records of new data.  Normally, a rebuild would skip such segments, but if force is set true, the segments will not be skipped.  (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call rebuildnowPostCall(String graphName, Integer threadnum, String vertextype, Integer segid, String path, Boolean force, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/rebuildnow/{graph_name}"
            .replaceAll("\\{" + "graph_name" + "\\}", apiClient.escapeString(graphName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (threadnum != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("threadnum", threadnum));
        if (vertextype != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("vertextype", vertextype));
        if (segid != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("segid", segid));
        if (path != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("path", path));
        if (force != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("force", force));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call rebuildnowPostValidateBeforeCall(String graphName, Integer threadnum, String vertextype, Integer segid, String path, Boolean force, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'graphName' is set
        if (graphName == null) {
            throw new ApiException("Missing the required parameter 'graphName' when calling rebuildnowPost(Async)");
        }
        
        com.squareup.okhttp.Call call = rebuildnowPostCall(graphName, threadnum, vertextype, segid, path, force, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Rebuild graph engine
     * In TigerGraph, when new data is being loaded into the graph (such as new vertices or edges),  data is first stored in memory before it is saved to disk permanently.  TigerGraph runs a rebuild of the Graph Processing Engine (GPE) to commit the data in memory to disk  every 30 seconds, but you can also call this endpoint to trigger a rebuild immediately. 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param threadnum Number of threads used to execute the rebuild. If not specified, the number specified in the .tg.cfg file  (\&quot;RebuildThreadNumber\&quot;) in the home directory of the server on which TigerGraph  is running will be used; it is set to 3 by default.  The maximum value for this parameter is the number of vCPUs per node in your distributed system.  If you are running a single-node server, the maximum is the number of vCPUs on that node.  You can run lscpu in the command line of your Linux server and look in the CPU(s)  column to view the number of vCPUs.  (optional)
     * @param vertextype Vertex type to perform the rebuild for. If not provided, the rebuild will be run for all the vertex types.  (optional)
     * @param segid Segment ID of the segments to rebuild. If not provided, all segments will be rebuilt.  In general, it is recommended not to provide this parameter and rebuild all segments.  (optional)
     * @param path Path to save the summary of the rebuild to. If not provided, the default path is /tmp/rebuildnow  (optional)
     * @param force Boolean value that indicates whether to perform rebuilds for segments for which there are no records of new data.  Normally, a rebuild would skip such segments, but if force is set true, the segments will not be skipped.  (optional)
     * @return HelloResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public HelloResponse rebuildnowPost(String graphName, Integer threadnum, String vertextype, Integer segid, String path, Boolean force) throws ApiException {
        ApiResponse<HelloResponse> resp = rebuildnowPostWithHttpInfo(graphName, threadnum, vertextype, segid, path, force);
        return resp.getData();
    }

    /**
     * Rebuild graph engine
     * In TigerGraph, when new data is being loaded into the graph (such as new vertices or edges),  data is first stored in memory before it is saved to disk permanently.  TigerGraph runs a rebuild of the Graph Processing Engine (GPE) to commit the data in memory to disk  every 30 seconds, but you can also call this endpoint to trigger a rebuild immediately. 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param threadnum Number of threads used to execute the rebuild. If not specified, the number specified in the .tg.cfg file  (\&quot;RebuildThreadNumber\&quot;) in the home directory of the server on which TigerGraph  is running will be used; it is set to 3 by default.  The maximum value for this parameter is the number of vCPUs per node in your distributed system.  If you are running a single-node server, the maximum is the number of vCPUs on that node.  You can run lscpu in the command line of your Linux server and look in the CPU(s)  column to view the number of vCPUs.  (optional)
     * @param vertextype Vertex type to perform the rebuild for. If not provided, the rebuild will be run for all the vertex types.  (optional)
     * @param segid Segment ID of the segments to rebuild. If not provided, all segments will be rebuilt.  In general, it is recommended not to provide this parameter and rebuild all segments.  (optional)
     * @param path Path to save the summary of the rebuild to. If not provided, the default path is /tmp/rebuildnow  (optional)
     * @param force Boolean value that indicates whether to perform rebuilds for segments for which there are no records of new data.  Normally, a rebuild would skip such segments, but if force is set true, the segments will not be skipped.  (optional)
     * @return ApiResponse&lt;HelloResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<HelloResponse> rebuildnowPostWithHttpInfo(String graphName, Integer threadnum, String vertextype, Integer segid, String path, Boolean force) throws ApiException {
        com.squareup.okhttp.Call call = rebuildnowPostValidateBeforeCall(graphName, threadnum, vertextype, segid, path, force, null, null);
        Type localVarReturnType = new TypeToken<HelloResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Rebuild graph engine (asynchronously)
     * In TigerGraph, when new data is being loaded into the graph (such as new vertices or edges),  data is first stored in memory before it is saved to disk permanently.  TigerGraph runs a rebuild of the Graph Processing Engine (GPE) to commit the data in memory to disk  every 30 seconds, but you can also call this endpoint to trigger a rebuild immediately. 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param threadnum Number of threads used to execute the rebuild. If not specified, the number specified in the .tg.cfg file  (\&quot;RebuildThreadNumber\&quot;) in the home directory of the server on which TigerGraph  is running will be used; it is set to 3 by default.  The maximum value for this parameter is the number of vCPUs per node in your distributed system.  If you are running a single-node server, the maximum is the number of vCPUs on that node.  You can run lscpu in the command line of your Linux server and look in the CPU(s)  column to view the number of vCPUs.  (optional)
     * @param vertextype Vertex type to perform the rebuild for. If not provided, the rebuild will be run for all the vertex types.  (optional)
     * @param segid Segment ID of the segments to rebuild. If not provided, all segments will be rebuilt.  In general, it is recommended not to provide this parameter and rebuild all segments.  (optional)
     * @param path Path to save the summary of the rebuild to. If not provided, the default path is /tmp/rebuildnow  (optional)
     * @param force Boolean value that indicates whether to perform rebuilds for segments for which there are no records of new data.  Normally, a rebuild would skip such segments, but if force is set true, the segments will not be skipped.  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call rebuildnowPostAsync(String graphName, Integer threadnum, String vertextype, Integer segid, String path, Boolean force, final ApiCallback<HelloResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = rebuildnowPostValidateBeforeCall(graphName, threadnum, vertextype, segid, path, force, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<HelloResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for statistics
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param seconds Duration of statistics collection (1  n  60). (optional, default to 10)
     * @param segments Integer that indicates the number of segments that LatencyPercentile array in the response will be split into. The value for this endpoint must be between 1 and 100 and has a default value of 10.  (optional, default to 10)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call statisticsCall(String graphName, Integer seconds, Integer segments, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/statistics/{graph_name}"
            .replaceAll("\\{" + "graph_name" + "\\}", apiClient.escapeString(graphName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (seconds != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("seconds", seconds));
        if (segments != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("segments", segments));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call statisticsValidateBeforeCall(String graphName, Integer seconds, Integer segments, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'graphName' is set
        if (graphName == null) {
            throw new ApiException("Missing the required parameter 'graphName' when calling statistics(Async)");
        }
        
        com.squareup.okhttp.Call call = statisticsCall(graphName, seconds, segments, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Show query performance
     * Returns real-time query performance statistics over the given time period, as specified by the **seconds** parameter.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_show_query_performance 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param seconds Duration of statistics collection (1  n  60). (optional, default to 10)
     * @param segments Integer that indicates the number of segments that LatencyPercentile array in the response will be split into. The value for this endpoint must be between 1 and 100 and has a default value of 10.  (optional, default to 10)
     * @return StatisticsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StatisticsResponse statistics(String graphName, Integer seconds, Integer segments) throws ApiException {
        ApiResponse<StatisticsResponse> resp = statisticsWithHttpInfo(graphName, seconds, segments);
        return resp.getData();
    }

    /**
     * Show query performance
     * Returns real-time query performance statistics over the given time period, as specified by the **seconds** parameter.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_show_query_performance 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param seconds Duration of statistics collection (1  n  60). (optional, default to 10)
     * @param segments Integer that indicates the number of segments that LatencyPercentile array in the response will be split into. The value for this endpoint must be between 1 and 100 and has a default value of 10.  (optional, default to 10)
     * @return ApiResponse&lt;StatisticsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StatisticsResponse> statisticsWithHttpInfo(String graphName, Integer seconds, Integer segments) throws ApiException {
        com.squareup.okhttp.Call call = statisticsValidateBeforeCall(graphName, seconds, segments, null, null);
        Type localVarReturnType = new TypeToken<StatisticsResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Show query performance (asynchronously)
     * Returns real-time query performance statistics over the given time period, as specified by the **seconds** parameter.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_show_query_performance 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param seconds Duration of statistics collection (1  n  60). (optional, default to 10)
     * @param segments Integer that indicates the number of segments that LatencyPercentile array in the response will be split into. The value for this endpoint must be between 1 and 100 and has a default value of 10.  (optional, default to 10)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call statisticsAsync(String graphName, Integer seconds, Integer segments, final ApiCallback<StatisticsResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = statisticsValidateBeforeCall(graphName, seconds, segments, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StatisticsResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for version
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call versionCall(String graphName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/version/{graph_name}"
            .replaceAll("\\{" + "graph_name" + "\\}", apiClient.escapeString(graphName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call versionValidateBeforeCall(String graphName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'graphName' is set
        if (graphName == null) {
            throw new ApiException("Missing the required parameter 'graphName' when calling version(Async)");
        }
        
        com.squareup.okhttp.Call call = versionCall(graphName, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Show component versions
     * This endpoint returns the GIT versions of all components of the system.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_show_component_versions 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @return HelloResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public HelloResponse version(String graphName) throws ApiException {
        ApiResponse<HelloResponse> resp = versionWithHttpInfo(graphName);
        return resp.getData();
    }

    /**
     * Show component versions
     * This endpoint returns the GIT versions of all components of the system.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_show_component_versions 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @return ApiResponse&lt;HelloResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<HelloResponse> versionWithHttpInfo(String graphName) throws ApiException {
        com.squareup.okhttp.Call call = versionValidateBeforeCall(graphName, null, null);
        Type localVarReturnType = new TypeToken<HelloResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Show component versions (asynchronously)
     * This endpoint returns the GIT versions of all components of the system.  See: https://docs.tigergraph.com/tigergraph-server/current/api/built-in-endpoints#_show_component_versions 
     * @param graphName The name of the graph (REQUIRED in case of multiple graph in the database). (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call versionAsync(String graphName, final ApiCallback<HelloResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = versionValidateBeforeCall(graphName, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<HelloResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
